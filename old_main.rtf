{\rtf1\ansi\ansicpg1252\cocoartf2512
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red88\green118\blue71;\red32\green32\blue32;}
{\*\expandedcolortbl;;\csgenericrgb\c34510\c46275\c27843;\csgenericrgb\c12549\c12549\c12549;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs24 \cf2 \cb3 """ OLD MAIN\
    # Original graph\
    index = ['A', 'B', 'C', 'D']\
    columns = ['activators', 'inhibitors']\
    content = [[['D', 'F'], ['']], [['A'], ['E']], [['E'], ['A']], [['B'], ['C']]]\
    original_data = pd.DataFrame(data=content, index=index, columns=columns)\
\
    # Fixed conflicts graphs.\
    # Be noticed that here they are the graph with the variables and the one without any conflict introduced\
    index = ['E', 'F']\
    columns = ['expressions', 'activated', 'inhibited']\
    content = [[['B', 'C'], ['C'], ['B']], [['A', 'B', 'C'], ['A'], ['']]]\
    fixed_conflicts_data = pd.DataFrame(data=content, index=index, columns=columns)\
\
    # Introduce the example of Huang\
    index = ['I', 'S', 'T', 'Z', 'D']\
    columns = ['activators', 'inhibitors']\
    content = [[[''], ['']], [['I'], ['S', 'T']], [[''], ['S', 'Z']], [['S', 'Z'], ['D']], [['D'], ['S', 'Z']]]\
    initial_data = pd.DataFrame(data=content, index=index, columns=columns)\
\
    # Unfixed conflicts graphs\
    index = ['E', 'F']\
    tag = 'variables'\
    columns = [tag]\
    content = [[['A', 'E']], [['A', 'D', 'E', 'F']]]\
    unfixed_conflicts_data = pd.DataFrame(data=content, index=index, columns=columns)\
\
    # Get another DataFrame with all the possible ncbf.\
    tags = ['activators', 'inhibitors']\
    initial_paths = ncbfCalc(data=initial_data, tags=tags)\
    original_paths = ncbfCalc(data=original_data, tags=tags)\
    unfixed_conflicts_paths, unfixed_conflicts_graphs = conflict_ncbfCalc(variables=unfixed_conflicts_data, tag=tag)\
\
    # Get all possible networks given the set of paths\
    original_networks = list(networksCalc(original_paths))\
    initial_networks = list(networksCalc(initial_paths))\
    unfixed_sets_conflicts_networks = []\
    for set_paths in unfixed_conflicts_paths:\
        unfixed_sets_conflicts_networks.append(list(networksCalc(set_paths)))\
\
    # Return the set of networks which meet the condition\
    attractors = ['00101', '11011', '11010']\
    final_networks = netValidator(initial_networks, initial_data, original_networks, original_data, attractors,\
                                  unfixed_sets_conflicts_networks, unfixed_conflicts_graphs, fixed_conflicts_data, tags)\
\
    # Filter by networks with coherent projection\
    networks = netFilter(final_networks)\
"""\
}